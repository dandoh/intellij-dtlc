package org.ice1000.tt.psi

import com.intellij.lexer.Lexer
import com.intellij.lexer.LexerBase
import com.intellij.psi.tree.IElementType
import com.intellij.psi.tree.TokenSet
import com.intellij.util.containers.IntStack
import org.ice1000.tt.psi.State.Normal
import org.ice1000.tt.psi.State.WaitingForLayout

data class LetIn(val letToken: IElementType, val inToken: IElementType)

/**
 * This is the main lexer. It wraps the underlying lexer generated by Flex
 * to synthesize special tokens based on whitespace-sensitive layout rules
 * in the layout-based languages. This makes it possible to write a
 * traditional parser using JFlex/Grammar-Kit.
 *
 * This is a modified version of:
 * https://github.com/klazuka/intellij-elm/blob/master/src/main/kotlin/org/elm/lang/core/lexer/ElmLayoutLexer.kt
 */
class LayoutLexer(
	val lexer: Lexer,
	private val endOfLine: IElementType,
	private val layoutStart: IElementType,
	private val layoutSeparator: IElementType,
	private val layoutEnd: IElementType,
	/*TokenSet.orSet(TokenSet.create(TokenType.WHITE_SPACE, TAB, endOfLine), ELM_COMMENTS)*/
	private val nonCodeTokens: TokenSet,
	/*TokenSet.create(LET, OF)*/
	private val layoutCreatingTokens: TokenSet,
	private val letInTokens: LetIn? = null,
	private val initialState: (List<Token>) -> State = { Normal }
) : LexerBase() {
	private val tokens = ArrayList<Token>(40)
	private var currentTokenIndex = 0
	private val currentToken: Token
		get() = tokens[currentTokenIndex]

	override fun start(buffer: CharSequence, startOffset: Int, endOffset: Int, initialState: Int) {
		require(startOffset == 0) { "does not support incremental lexing: startOffset must be 0" }
		require(initialState == 0) { "does not support incremental lexing: initialState must be 0" }

		// Start the incremental lexer
		lexer.start(buffer, startOffset, endOffset, initialState)

		doLayout()
		currentTokenIndex = 0
	}

	override fun getState() = lexer.state
	override fun getBufferSequence() = lexer.bufferSequence
	override fun getBufferEnd() = lexer.bufferEnd

	override fun getTokenType() = currentToken.elementType
	override fun getTokenStart() = currentToken.start
	override fun getTokenEnd() = currentToken.end

	override fun advance() {
		if (currentToken.isEOF || currentToken.elementType == null) return
		currentTokenIndex++
	}

	inner class Token(
		@JvmField val elementType: IElementType?,
		@JvmField val start: Int,
		@JvmField val end: Int,
		@JvmField val column: Int,
		@JvmField val line: Line
	) {
		override fun toString() = "${elementType.toString()} ($start, $end)"
		val isEOF: Boolean get() = elementType == null
		val isCode: Boolean get() = elementType !in nonCodeTokens && !isEOF
		fun isNextLayoutLine() = isCode && column == line.columnWhereCodeStarts
	}

	private fun slurpTokens() {
		var line = Line()
		var currentColumn = 0
		while (true) {
			val token = Token(lexer.tokenType, lexer.tokenStart, lexer.tokenEnd, currentColumn, line)
			tokens.add(token)

			if (line.columnWhereCodeStarts == null && token.isCode) {
				line.columnWhereCodeStarts = currentColumn
			}

			currentColumn += token.end - token.start

			if (token.isEOF) {
				break
			} else if (token.elementType == endOfLine) {
				line = Line()
				currentColumn = 0
			}

			lexer.advance()
		}
	}

	private fun doLayout() {
		slurpTokens()

		// initial state
		var i = 0
		var state = initialState(tokens)
		val indentStack = IndentStack()
		indentStack.push(-1) // top-level is an implicit section

		while (true) {
			val token = tokens[i]

			when (state) {
				WaitingForLayout -> {
					if (token.isCode && token.column > indentStack.peek()) {
						tokens.add(i, virtualToken(layoutStart, tokens[(i - 1).coerceAtLeast(0)]))
						i++
						indentStack.push(token.column)
						if (token.elementType !in layoutCreatingTokens) state = Normal
					} else if (token.isNextLayoutLine() && token.column <= indentStack.peek()) {
						// The program is malformed: most likely because the new section is empty
						// (the user is still editing the text) or they did not indent the section.
						// The empty section case is a common workflow, so we must handle it by bailing
						// out of section building and re-process the token in the 'Normal' state.
						// If, instead, the problem is that the user did not indent the text,
						// tough luck (although we may want to handle this better in the future).
						state = Normal
						i--
					}
				}
				Normal -> {
					if (token.elementType in layoutCreatingTokens) state = WaitingForLayout
					if (token.isNextLayoutLine()) i = insideLayout(i, token, indentStack)
					if (letInTokens != null && isSingleLineLetIn(i, tokens, letInTokens)) {
						tokens.add(i, virtualToken(layoutEnd, tokens[i - 1]))
						i++
						indentStack.pop()
					}
				}
			}
			if (token.elementType == null) while (indentStack.pop() >= 0) {
				tokens.add(virtualToken(layoutEnd, token))
				i++
			}

			i++
			if (i >= tokens.size) break
		}
	}

	/**
	 * Extracted from [doLayout] to reduce indentation.
	 */
	private fun insideLayout(i: Int, token: Token, indentStack: IndentStack): Int {
		var insertAt = i

		// We want to insert virtual tokens immediately after the newline that follows
		// the last code token. This is important so that:
		//
		//   (1) trailing spaces at the end of the declaration are part of the declaration
		//   (2) top-level comments that follow the declaration are NOT part of the declaration
		//
		// Note that a virtual token has to appear after a whitespace token, since the real token
		// is combined with the virtual token during parsing (their text ranges overlap).
		loop@ for (k in (i - 1) downTo 1) if (tokens[k].isCode)
			for (m in (k + 1) until (i + 1)) if (tokens[m].elementType == endOfLine) {
				insertAt = m
				break@loop
			}

		val precedingToken = tokens[insertAt]

		var mutI = i
		while (!indentStack.empty()) if (token.column == indentStack.peek()) {
			tokens.add(insertAt, virtualToken(layoutSeparator, precedingToken))
			mutI++
			break
		} else if (token.column < indentStack.peek()) {
			tokens.add(insertAt, virtualToken(layoutEnd, precedingToken))
			mutI++
			insertAt++
			indentStack.pop()
		} else break
		return mutI
	}

	private fun virtualToken(elementType: IElementType, precedesToken: Token) = Token(
		elementType = elementType,
		start = precedesToken.start,
		end = precedesToken.start, // yes, this is intentional
		column = precedesToken.column,
		line = precedesToken.line
	)
}

enum class State {
	/*
	 * The start state.
	 * Do not perform layout until we get to the first real line of code.
	 *
	 * In DTLC, there can be layout at the beginning of files.
	 */
	/*Start,*/

	/**
	 * Waiting for the first line of code inside a let/in or case/of in order to open a new section.
	 */
	WaitingForLayout,

	/**
	 * Looking to emit virtual delimiters between declarations at the same indent level
	 * and closing out sections when appropriate.
	 */
	Normal;
}

private fun isSingleLineLetIn(
	index: Int, tokens: List<LayoutLexer.Token>,
	letInTokens: LetIn
): Boolean {
/*
	Many languages allows for a let/in expression on a single line:
	e.g. ```foo = let x = 0 in x + 1```
	I don't know why you would ever do this, but some people do:
	https://github.com/klazuka/intellij-elm/issues/20#issuecomment-374843581

	If we didn't have special handling for it, the `let` section wouldn't
	get closed-out until a subsequent line with less indent, which would be wrong.
*/

	val token = tokens[index]
	if (token.elementType != letInTokens.inToken)
		return false

	val thisLine = token.line
	var i = index
	do {
		val t = tokens[i--]
		if (t.elementType == letInTokens.letToken)
			return true
	} while (t.line == thisLine && i in 0 until tokens.size)


	return false
}

/**
 * In a well-formed program, there would be no way to underflow the indent stack,
 * but this lexer will be asked to lex malformed/partial programs, so we need
 * to guard against trying to use the stack when it's empty.
 */
private class IndentStack : IntStack() {
	override fun peek() = if (super.empty()) -1 else super.peek()
	override fun pop() = if (super.empty()) -1 else super.pop()
}

class Line(@JvmField var columnWhereCodeStarts: Int? = null)
