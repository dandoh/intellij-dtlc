//noinspection BnfResolveForFile
{
  generate=[java="8" names="long"]

  parserClass="org.ice1000.tt.psi.agda.AgdaParser"

  psiClassPrefix="Agda"
  psiImplClassSuffix="Impl"
  psiPackage="org.ice1000.tt.psi.agda"
  psiImplPackage="org.ice1000.tt.psi.agda.impl"

  elementTypeHolderClass="org.ice1000.tt.psi.agda.AgdaTypes"
  elementTypeClass="org.ice1000.tt.psi.agda.AgdaElementType"
  tokenTypeClass="org.ice1000.tt.psi.agda.AgdaTokenType"

  extends(".*Exp")=exp
  extends(".*Block")=declaration
}

/// This is just a placeholder.
file ::= module | (LAYOUT_SEP? declaration)*
nameDecl ::= IDENTIFIER

module ::= KW_MODULE nameExp KW_WHERE
 layout {
	pin=1
	extends=declaration
}

signature ::= nameDecl+ COLON exp whereClause? {
	pin=2
	extends=declaration
}
implementation ::= lhs EQUAL exp whereClause? {
	pin=2
	extends=declaration
}
withAbstraction ::= exp KW_WITH exp {
	pin=2
	extends=declaration
}
private unquoteKeywords ::=
   KW_UNQUOTE_DEF
 | KW_UNQUOTE_DECL
 | KW_OPEN
unquote ::= unquoteKeywords exp {
	pin=1
	extends=declaration
}
private aliasKeywords ::=
   KW_PATTERN
 | KW_SYNTAX
alias ::= aliasKeywords implementation {
	pin=1
	extends=declaration
}
private infixKeywords ::=
   KW_INFIX
 | KW_INFIXL
 | KW_INFIXR
infix ::= infixKeywords NUMBER nameExp+ {
	pin=1
	extends=declaration
}
importPackage ::= KW_OPEN? KW_IMPORT nameExp (visibility | renaming)* {
	pin=2
}
visibilityKeywords ::= "using" | "hiding"
visibility ::= visibilityKeywords OPEN_PAREN (nameExp nameExpRest*)? CLOSE_PAREN { pin=1 }
private nameExpRest ::= SEMI nameExp { pin=1 }

renaming ::= "renaming" OPEN_PAREN (renamePair renamePairRest*)? CLOSE_PAREN { pin=1 }
renamePair ::= nameExp "to" nameDecl
private renamePairRest ::= SEMI renamePair { pin=1 }

macro ::= KW_MACRO layout { pin=1 }
whereClause ::= KW_WHERE layout { pin=1 }
whereSignatureClause ::= KW_WHERE layoutSignature { pin=1 }
whereRecordClause ::= KW_WHERE layoutRecord { pin=1 }

data ::= (KW_DATA | KW_CODATA) signature whereSignatureClause { pin=1 }
record ::= KW_RECORD signature whereRecordClause { pin=1 }

recordDecl ::=
   recordDeclKeywords
 | recordFields
 | recordConstructor

recordConstructor ::= KW_CONSTRUCTOR IDENTIFIER {
	pin=1
	extends=recordDecl
}

recordDeclKeywords ::=
   KW_ETA_EQUALITY
 | KW_INDUCTIVE
 | KW_COINDUCTIVE
 | KW_NO_ETA_EQUALITY {
	extends=recordDecl
}

recordFields ::= KW_FIELD layoutSignature {
	pin=1
	extends=recordDecl
}

declaration ::=
   signature
 | implementation
 | module
 | block
 | data
 | record
 | alias
 | infix
 | importPackage
 | withAbstraction
 | macro
 | unquote

private blockKeyword ::=
   KW_PRIMITIVE
 | KW_PRIVATE
 | KW_VARIABLE
 | KW_POSTULATE
 | KW_ABSTRACT
 | KW_INSTANCE
 | KW_MUTUAL
block ::= blockKeyword layout { pin=1 }

private lhsStart ::= exp | ELLIPSIS
lhs ::= lhsStart barExp* rewriting? { pin=1 }
rewriting ::= KW_REWRITE exp barExp* { pin=1 }
private barExp ::= BAR exp { pin=1 }

layout ::= declaration | indentationLayout
private indentationLayout ::=
 LAYOUT_START
  (declaration (LAYOUT_SEP? declaration)*)?
 LAYOUT_END? { pin=1 }

layoutSignature ::= signature | indentationSignatureLayout
private indentationSignatureLayout ::=
 LAYOUT_START
  (signature (LAYOUT_SEP? signature)*)?
 LAYOUT_END? { pin=1 }

layoutRecord ::= recordDecl | indentationRecordLayout
private indentationRecordLayout ::=
 LAYOUT_START
  (recordDecl (LAYOUT_SEP? recordDecl)*)?
 LAYOUT_END? { pin=1 }

exp ::=
   type2Exp
 | asExp
 | appExp
 | atomic

appExp ::= exp exp+
private atomic ::=
   string
 | atomicExp
 | nameExp
 | typeExp
 | lamExp
 | idiomExp
 | matchExp
 | recordExp
 | dotExp
 | quoteExp
 | letExp
 | instanceExp
 | doExp
 | parenExp

atomicExp ::=
   UNDERSCORE
 | QUESTION_MARK
 | HOLE
 | UNIVERSE
 | NUMBER
 | FLOAT
 | OPEN_PAREN CLOSE_PAREN
nameExp ::= IDENTIFIER (DOT IDENTIFIER)*
typeExp ::= arg exp
type2Exp ::= exp ARROW exp
asExp ::= exp AS nameExp
lamExp ::= LAMBDA exp ARROW exp { pin=3 }
matchExp ::= LAMBDA OPEN_BRACE clauses CLOSE_BRACE { pin=2 }
parenExp ::= OPEN_PAREN exp CLOSE_PAREN { pin=2 }
idiomExp ::= OPEN_IDIOM_BRACKET exp CLOSE_IDIOM_BRACKET { pin=1 }
recordExp ::= KW_RECORD OPEN_BRACE clauses CLOSE_BRACE { pin=1 }
dotExp ::= DOT exp { pin=1 }
quoteExp ::= quoteKeyword exp { pin=1 }
letExp ::= KW_LET layout KW_IN exp { pin=1 }
doExp ::= KW_DO layout { pin=1 }
instanceExp ::= OPEN_BRACE OPEN_BRACE exp CLOSE_BRACE CLOSE_BRACE { pin=2 }
string ::= CHR_LIT | STR_LIT {
	mixin='org.ice1000.tt.psi.agda.AgdaStringMixin'
	extends=exp
}

clause ::= exp ARROW exp { pin=2 }
private clauses ::= clause restClauses*
private restClauses ::= SEMI clause { pin=1 }

arg ::= argPrefix ARROW?
private argPrefix ::=
   explicitArg
 | implicitArg
 | instanceArg
 | forallArg
explicitArg ::= OPEN_PAREN signature CLOSE_PAREN { pin=1 }
implicitArg ::= OPEN_BRACE signature CLOSE_PAREN { pin=2 }
instanceArg ::= OPEN_BRACE OPEN_BRACE signature CLOSE_PAREN CLOSE_PAREN { pin=2 }
forallArg ::= KW_FORALL nameDecl+ { pin=1 }

private quoteKeyword ::=
   KW_QUOTE
 | KW_QUOTE_TERM
 | KW_QUOTE_GOAL
 | KW_QUOTE_CONTEXT
 | KW_UNQUOTE
 | KW_TACTIC
 | KW_OVERLAP
