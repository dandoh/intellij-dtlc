//noinspection BnfResolveForFile
{
  generate=[java="8" names="long"]

  parserClass="org.ice1000.tt.psi.redprl.RedPrlParser"

  psiClassPrefix="RedPrl"
  psiImplClassSuffix="Impl"
  psiPackage="org.ice1000.tt.psi.redprl"
  psiImplPackage="org.ice1000.tt.psi.redprl.impl"

  elementTypeHolderClass="org.ice1000.tt.psi.redprl.RedPrlTypes"
  elementTypeClass="org.ice1000.tt.psi.redprl.RedPrlElementType"
  tokenTypeClass="org.ice1000.tt.psi.redprl.RedPrlTokenType"

  extends("mlCmd.+")=mlCmd
  extends("mlDecl.+")=mlDecl
  extends("multitac.+")=atomicMultitac
  extends("[^T]+Tac")=tac
}

// Regular expressions:
//  s/\(Ast\.\$\$[^\n]+//rg

file ::= mlDecl mlDeclRest*
private mlDeclRest ::= DOT mlDecl? { pin=1 }

ident ::= VARNAME | OPNAME

boundVar ::= VARNAME | UNDER

sort ::=
   EXP
 | TAC_KW
 | JDG
 | LVL
 | KND
 | DIM

opUsage ::= OPNAME
opDecl ::= OPNAME
varUsage ::= VARNAME {
	extends=termAndTac
	extends=term
}
varDecl ::= VARNAME

numAsDimension ::= NUMERAL

bindingSig ::= LSQUARE sort+ RSQUARE DOT { pin=1 }
private valence ::= bindingSig? sort { pin=1 }

private dimension ::= varUsage | metaVar | numAsDimension
dir ::= dimension SQUIGGLE_RIGHT_ARROW dimension
backDir ::= dimension SQUIGGLE_LEFT_ARROW dimension
equation ::= dimension EQUALS dimension
tube ::= LSQUARE equation binding RSQUARE
boundary ::= LSQUARE equation term RSQUARE
metaVar ::= HASH ident

typedBinder ::= LSQUARE boundVar+ COLON term RSQUARE { pin=4 }
dimBinder ::= LSQUARE boundVar+ COLON DIM RSQUARE { pin=4 }

arrowQuantifierData ::=
   typedBinder arrowQuantifierData
 | dimBinder arrowQuantifierData
 | term arrowQuantifierData
 | DIM arrowQuantifierData
 | term
timesQuantifierData ::=
   typedBinder timesQuantifierData
 | term timesQuantifierData
 | term

field ::= LSQUARE ident term RSQUARE
private binder ::= LSQUARE boundVar+ RSQUARE
binding ::= binder? term

nullaryOperator ::=
 /* axiom */
   AX
 /* bools */
 | BOOL
 | TT
 | FF
 /* natural numbers */
 | NAT
 | ZERO
 /* integers */
 | INT
 /* void */
 | VOID
 /* circle */
 | S1
 | BASE

 | kind

multinaryOperator ::=
 /* bools */
   IF
 /* natural numbers */
 | SUCC
 | NAT_REC
 /* integers */
 | POS
 | NEGSUCC
 | INT_REC
 /* S1 */
 | S1_REC
 /* paths */
 | PATH
 /* lines */
 | LINE
 /* pushouts */
 | PUSHOUT
 | LEFT
 | RIGHT
 | GLUE
 | PUSHOUT_REC
 /* coequalizers */
 | COEQUALIZER
 | CECOD
 | CEDOM
 | COEQUALIZER_REC
 /* equality */
 | EQUALS
 /* V */
 | V
 | VIN
 | VPROJ

customOpTerm ::= opUsage | LPAREN opUsage binding+ RPAREN

private inductiveTermInside ::=
   TYPE binding*
 | ident binding*
 | REC binding+
inductiveTerm ::= LPAREN DOT opUsage inductiveTermInside RPAREN

patVar ::=
   PERCENT LSQUARE varDecl COLON sort RSQUARE
 | PERCENT varDecl

termAndTac ::=
   varUsage
 /* meta variable */
 | metaVar
 /* pattern variables */
 | patVar

 | ttMetaOrPattern

 /* custom operators */
 | customOpTerm

 /* inductive types */
 | inductiveTerm

 /* built-in operators that can be handled uniformly */
 | nullaryOperator
 | ttMultinary
 | ttUniverse
 | LPAREN LOOP dimension RPAREN

 /* Kan operators */
 | LPAREN COE dir binding term RPAREN
 | LPAREN FCOM dir term tube* RPAREN
 | LPAREN HCOM dir binding term tube* RPAREN
 | LPAREN COM dir binding term tube* RPAREN
 | LPAREN BOX dir term boundary* RPAREN
 | LPAREN CAP backDir term tube* RPAREN
 | LPAREN ECOM dir term tube* RPAREN

 /* numbers */
 | NUMERAL
 | ttDimNatInt

 /* function types */
 | ttRArrow
 | LPAREN LAMBDA LSQUARE boundVar+ RSQUARE term RPAREN
 | LPAREN DOLLAR_SIGN term term+ RPAREN

 /* pair types */
 | LPAREN TIMES timesQuantifierData RPAREN

 /* dependent record types */
 | RECORD
 | ttParenRecord
 | TUPLE
 | LPAREN TUPLE (field+ | term+) RPAREN
 | ttBang

 /* paths */
 | LPAREN ABS LSQUARE boundVar+ RSQUARE term RPAREN
 | LPAREN AT_SIGN term dimension+ RPAREN

 /* Abbreviation for membership */
 | ttMem

 /* levels */
 | ttPlus
 | ttDoublePlus
 | ttLMax {
	extends=tac
	extends=term
	extends=atomicMultitac
}

private ttMem ::= LPAREN MEM term term RPAREN { pin=2 }
private ttDoublePlus ::= LPAREN DOUBLE_PLUS level RPAREN { pin=2 }
private ttPlus ::= LPAREN PLUS level NUMERAL RPAREN { pin=2 }
private ttMultinary ::= LPAREN multinaryOperator binding+ RPAREN { pin=2 }
private ttUniverse ::= LPAREN UNIVERSE level term? RPAREN { pin=2 }
private ttLMax ::= LPAREN LMAX level+ RPAREN { pin=2 }
private ttBang ::= LPAREN BANG ident term RPAREN { pin=2 }
private ttRArrow ::= LPAREN RIGHT_ARROW arrowQuantifierData RPAREN { pin=2 }
private ttDimNatInt ::= LPAREN (DIM | NAT | INT) NUMERAL RPAREN { pin=2 }
private ttMetaOrPattern ::= LPAREN (metaVar | patVar) term+ RPAREN { pin=2 }
private ttParenRecord ::= LPAREN RECORD typedBinder+ RPAREN { pin=2 }

level ::=
   NUMERAL
 | ttPlus
 | ttDoublePlus
 | ttLMax
 | metaVar
 | PERCENT varUsage

term ::=
   termAndTac
 | HASH TAC_KW LBRACKET tactic RBRACKET
 | HASH JDG LBRACKET judgment RBRACKET
 | HASH LVL LBRACKET level RBRACKET

kind ::=
   DISCRETE
 | KAN
 | HCOM
 | COE
 | PRE
withKind ::= WITH term
judgment ::=
   term EQUALS term IN term
 | term IN term
 | term TRUE
 | term
 | term EQUALS term TYPE withKind?
 | term TYPE withKind?

specTube ::= LSQUARE equation specBinding RSQUARE
specBoundary ::= LSQUARE equation specTerm RSQUARE

specArrowQuantifierData ::= (typedBinder | term)* specType
specType ::= SELF | LPAREN SELF RIGHT_ARROW specArrowQuantifierData RPAREN
specTypedBinder ::= LSQUARE boundVar+ COLON specType RSQUARE

specBinding ::= binder? specTerm

specTerm ::=
   term

 /* intro */
 | LPAREN SELF ident specBinding* RPAREN

 /* fcom */
 | LPAREN SELF FCOM dir specTerm specTube+ RPAREN

 /* lambda and applications */
 | LPAREN SELF LAMBDA LSQUARE boundVar+ RSQUARE specTerm RPAREN
 | LPAREN SELF DOLLAR_SIGN specTerm term+ RPAREN

private possibleDataConstructor ::=
   typedBinder
 | dimBinder
 | specTypedBinder
 | specType
 | specBoundary+
 | term
 | DIM
private dataConstructors ::= dataConstructor dataConstructorRest*
private dataConstructorRest ::= COMMA dataConstructor { pin=1 }
dataConstructor ::= ident possibleDataConstructor*

dataDecl ::=
 (typedBinder | dimBinder)*
 COLON LPAREN UNIVERSE level KAN RPAREN LBRACKET dataConstructors RBRACKET

private recordFieldTactics ::= recordFieldTactic recordFieldTacticRest*
private recordFieldTacticRest ::= COMMA recordFieldTactic { pin=1 }
recordFieldTactic ::= varDecl EQUALS tactic { pin=2 }

private devAppSpineRest ::= COMMA devAppSpine { pin=1 }
private bracketedDevAppSpine ::= LSQUARE devAppSpine? RSQUARE { pin=1 }
devAppSpine ::= tactic devAppSpineRest*

devDecompPattern ::= varDecl | UNDER | LBRACKET tupleDecompPattern RBRACKET
labeledDecompPattern ::= varDecl EQUALS devDecompPattern { pin=2 }

private labeledDecompPatternRest ::= COMMA labeledDecompPattern { pin=1 }
labeledTupleDecompPattern ::= labeledDecompPattern labeledDecompPatternRest*

private devDecompPatternRest ::= COMMA devDecompPattern { pin=1 }
anonTupleDecompPattern ::= devDecompPattern devDecompPatternRest*

private tupleDecompPattern ::=
   anonTupleDecompPattern
 | labeledTupleDecompPattern?
devMatchClauses ::= LSQUARE (varDecl+ PIPE)? term
 DOUBLE_RIGHT_ARROW tactic RSQUARE

selector ::= CONCL | elimTarget
accessor ::= TYPE | LEFT | RIGHT

private elimTarget ::= varUsage | metaVar

tac ::=
   refineTac
 | simpleTac
 | elimTac
 | rewriteTac
 | reduceTac
 | unfoldTac
 | backtickTac
 | exactTac
 // %prec DOUBLE_PIPE
 | tacPipeTac
 | lambdaTac
 | absTac
 | bracketTac
 | withoutTac
 | withTac
 | ifTac
 | claimTac
 | letElimTac
 | letCustomTac
 | useElimTac
 | useCustomTac
 | caseTac
 | matchTac
 | queryTac
 | printTac

 /* overlapping with term */
 | termAndTac

// No-pin tactics
useElimTac ::= USE elimTarget bracketedDevAppSpine?
useCustomTac ::= USE customOpTerm bracketedDevAppSpine?
letCustomTac ::= LET devDecompPattern EQUALS
 customOpTerm bracketedDevAppSpine? SEMI tactic
letElimTac ::= LET devDecompPattern EQUALS
 elimTarget bracketedDevAppSpine? SEMI tactic

// Simple (can-pin) tactics
elimTac ::= TAC_ELIM elimTarget { pin=1 }
refineTac ::= REFINE varUsage { pin=1 }
queryTac ::= QUERY varDecl LEFT_ARROW selector SEMI tactic { pin=1 }
printTac ::= PRINT term { pin=1 }
caseTac ::= CASE elimTarget OF
 BASE DOUBLE_RIGHT_ARROW tactic
 PIPE LOOP varDecl DOUBLE_RIGHT_ARROW tactic { pin=1 }
matchTac ::= MATCH term LBRACKET devMatchClauses? RBRACKET { pin=1 }
ifTac ::= IF elimTarget THEN tactic ELSE tactic { pin=1 }
backtickTac ::= BACK_TICK term { pin=1 }
claimTac ::= CLAIM varDecl COLON judgment
 BY LBRACKET tactic RBRACKET SEMI tactic { pin=1 }
exactTac ::= RULE_EXACT term { pin=1 }
absTac ::= ABS boundVar+ DOUBLE_RIGHT_ARROW tactic { pin=1 }
lambdaTac ::= LAMBDA devDecompPattern+ DOUBLE_RIGHT_ARROW tactic { pin=1 }
bracketTac ::= LBRACKET (tactics | recordFieldTactics?) RBRACKET { pin=1 }
withoutTac ::= WITHOUT term+ { pin=1 }
withTac ::= WITH hypBinding* DOUBLE_RIGHT_ARROW tactic { pin=1 }

// Left-recursive tactics
tacPipeTac ::= tac DOUBLE_PIPE tactic

// Complicated tactics
private accessAndSelect ::=
   atAccessor | inSelector | atAccessor inSelector | inSelector atAccessor
private inSelector ::= IN selector
private atAccessor ::= AT accessor+
rewriteTac ::= TAC_REWRITE term accessAndSelect { pin=1 }
unfoldTac ::= TAC_UNFOLD opUsage+ accessAndSelect? { pin=1 }
reduceTac ::= TAC_REDUCE accessAndSelect? { pin=1 }

// Atomic tactics
simpleTac ::=
   TAC_ID
 | TAC_FAIL
 | TAC_AUTO_STEP
 | TAC_SYMMETRY
 | TAC_INVERSION
 | TAC_ASSUMPTION

atomicMultitac ::=
   multitacSquare
 | multitacHash
 | multitacRepeat
 | multitacAuto
 | multitacProgress
 | multitacParen
 | hole
 /// %prec SEMI
 | tac {
	extends=tactic
}

multitacSquare ::= LSQUARE tactics RSQUARE { pin=1 }
multitacRepeat ::= MTAC_REPEAT LBRACKET tactic RBRACKET { pin=1 }
multitacAuto ::= MTAC_AUTO
multitacProgress ::= MTAC_PROGRESS LBRACKET tactic RBRACKET { pin=1 }
multitacParen ::= LPAREN tactic RPAREN
multitacHash ::= HASH NUMERAL LBRACKET tactic RBRACKET { pin=1 }
hole ::= HOLENAME { extends=atomicMultitac }

/// %prec SEMI
tactic ::= atomicMultitac multitacRest* SEMI?
private multitacRest ::= SEMI atomicMultitac { pin=1 }

/// %prec COMMA
hypBinding ::= boundVar (COLON sort)?

private tactics ::= tactic tacticRest* COMMA?
private tacticRest ::= COMMA tactic { pin=1 }
/// %prec: SEMI

private declArguments ::= declArgument declArgumentRest*
private declArgumentRest ::= COMMA declArgument { pin=1 }
declArgument ::= metaVar (COLON valence)?

/// Should always use `declArgumentsParensOpt` instead of `declArgumentsParens`
declArgumentsParens ::= LPAREN declArguments? RPAREN { pin=1 }

private mlVtyBrack ::= LBRACKET mlCty RBRACKET { pin=1 }
mlVty ::= mlParen | mlVtyBrack

private mlCtyCaret ::= CARET mlVty { pin=1 }
private mlCtyVty ::= mlVty RIGHT_ARROW mlCty { pin=1 }
mlCty ::= mlCtyCaret | mlCtyVty

private mlParen ::= LPAREN RPAREN
private mlValueBrack ::= LBRACKET mlCmd RBRACKET { pin=1 }
mlValue ::=
   opUsage
 | mlValueBrack
 | mlParen

private mlAtomicPrint ::= PRINT mlValue { pin=1 }
private mlAtomicExtract ::= EXTRACT mlValue { pin=1 }
private mlAtomicCaret ::= CARET mlValue { pin=1 }
private mlAtomicBang ::= BANG mlValue { pin=1 }
mlAtomicCmd ::=
   mlAtomicPrint
 | QUIT
 | mlAtomicExtract
 | mlAtomicCaret
 | mlAtomicBang

mlCmdLet ::= LET mlDecl SEMI mlCmd {
	pin=1
}
mlCmdFn ::= FN opDecl COLON mlVty DOUBLE_RIGHT_ARROW mlCmd {
	pin=1
}
mlCmdValue ::= mlValue RANGLE mlCmd { pin=1 }

mlCmd ::=
   mlCmdLet
 | mlCmdFn
 | mlCmdValue
 | mlAtomicCmd

mlDeclDef ::= DEFINE opDecl declArgumentsParens?
 (COLON sort)? EQUALS term {
	pin=1
}
mlDeclData ::= DATA opDecl declArgumentsParens? dataDecl
 BY LBRACKET tactic RBRACKET {
	pin=1
}
mlDeclTactic ::= TACTIC_KW opDecl declArgumentsParens?
 EQUALS LBRACKET tactic RBRACKET {
	pin=1
}
mlDeclTheorem ::= THEOREM opDecl declArgumentsParens? COLON judgment
 BY LBRACKET tactic RBRACKET {
	pin=1
}
mlDeclVal ::= VAL opDecl EQUALS mlCmd {
	pin=1
}

mlDecl ::=
   mlDeclDef
 | mlDeclData
 | mlDeclTactic
 | mlDeclTheorem
 | mlDeclVal
 | mlCmd
