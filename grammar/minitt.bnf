{
  generate=[java="8" names="long"]

  parserClass="org.ice1000.tt.psi.MiniTTParser"
  extends="org.ice1000.tt.psi.impl.MiniTTElement"

  psiClassPrefix="MiniTT"
  psiImplClassSuffix="Impl"
  psiPackage="org.ice1000.tt.psi"
  psiImplPackage="org.ice1000.tt.psi.impl"

  elementTypeHolderClass="org.ice1000.tt.psi.MiniTTTypes"
  elementTypeClass="org.ice1000.tt.psi.MiniTTElementType"
  tokenTypeClass="org.ice1000.tt.psi.MiniTTTokenType"
}

expression ::=
   declaration
 | const_declaration
 | merge_sum
 | application
 | function_type
 | pair_type
 | first
 | second
 | pair
 | atom

atom ::=
   universe
 | sum
 | constructor
 | variable
 | split
 | one
 | unit
 | pi_type
 | sigma_type
 | lambda_expression
 | LEFT_PAREN expression RIGHT_PAREN
 { extends=expression }

// Syntactic sugars: short-hand for unit patterns
function_type ::= atom ARROW expression
pair_type ::= atom MUL expression

// Higher-level expressions
first ::= atom DOT_ONE { extends=expression }
second ::= atom DOT_TWO { extends=expression }
application ::= atom expression { extends=expression }
pair ::= atom COLON expression { pin=2 extends=expression }
merge_sum ::= atom CONCAT expression { pin=2 extends=expression }
variable ::= IDENTIFIER { extends=expression }

// Prefixed parameters
prefix_parameter ::= LEFT_PAREN typed_pattern RIGHT_PAREN

// Patterns
pattern ::= pair_pattern | atom_pattern
atom_pattern ::= IDENTIFIER | META_VAR | LEFT_PAREN pattern RIGHT_PAREN { extends=pattern }
pair_pattern ::= atom_pattern COLON pattern { pin=2 extends=pattern }
maybe_pattern ::= pattern? { extends=pattern }

// Extracted helpers
typed_pattern ::= pattern COMMA expression { pin=2 }
typed_abstraction ::= typed_pattern DOT expression { pin=2 }
branches ::= LEFT_BRACE (constructor (SEP constructor)*)? RIGHT_BRACE { pin=1 }
choices ::= LEFT_BRACE (pattern_match (SEP pattern_match)*)? RIGHT_BRACE { pin=1 }

// Atomic expressions
pi_type ::= PI typed_abstraction { pin=1 extends=expression }
lambda_expression ::= LAMBDA pattern DOT expression { pin=1 extends=expression }
constructor ::= CONSTRUCTOR_NAME expression? { pin=1 extends=expression }
pattern_match ::=
 CONSTRUCTOR_NAME
 maybe_pattern
 DOUBLE_ARROW
 expression { pin=1 }

sigma_type ::= SIGMA typed_abstraction { pin=1 extends=expression }
split ::= SPLIT_KEYWORD choices { pin=1 extends=expression }
sum ::= SUM_KEYWORD branches { pin=1 extends=expression }

one ::= ONE_KEYWORD { extends=expression }
unit ::= UNIT_KEYWORD { extends=expression }
universe ::= TYPE_UNIVERSE { extends=expression }

// Declaration
const_declaration ::=
 CONST_KEYWORD
 pattern
 EQ expression
 SEMICOLON expression?
 { pin=1 extends=expression }

declaration ::=
 (LET_KEYWORD | REC_KEYWORD)
 pattern
 prefix_parameter*
 COLON expression
 EQ expression
 SEMICOLON expression?
 { pin=1 extends=expression }
